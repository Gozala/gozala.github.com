---
layout: post
title: Some Mock-up around Ubiquity
tags: ubiquity mockup
---

In this post I am planing to talk about new Ubiquity command I'm working on currently and share some of my thought about:
<ul>
	<li>Ubiquity in general.</li>
	<li>Problems I've faced during development.</li>
	<li>Ideas how to improve</li>
</ul>
<img src="http://farm4.static.flickr.com/3534/3212467124_9751ae95d3_o.jpg" alt="http://farm4.static.flickr.com/3534/3212467124_9751ae95d3_o.jpg" width="420" height="315" />

Not a long time ago I realized that I've posted about several ubiquity commands I have developed, but I never tried to share my opinion about the project in general, so I'm going to do it now. I think that Ubiquity is just Incredible way to increase usability of the browser from the one hand and usability of web services from the other hand. Another reason why Ubiquity is a really cool project is an API. Developers are able to write almost quite complex commands keeping the process amazingly simple. I'm pretty sure that one hour playing with ubiquity is quite enough for any web developer to start writing own commands. Besides wiki has a <a href="https://wiki.mozilla.org/Labs/Ubiquity/Ubiquity_0.1_Author_Tutorial#The_Ubiquity_0.1_Command_Tutorial" target="_blank">nice tutorial</a> to get you up to speed.
Before I will start talking about difficulties I've faced, I will describe briefly the command itself.

Well actually it's not just a command, it's a set of commands for working with <a href="http://www.bugzilla.org/" target="_blank">Bugzilla</a>. As you might know Bugzilla has standard API for external programs that want to interact with it. Methods can be accessed via <a href="http://www.xmlrpc.com/spec" target="_blank">XML-RPC</a>. So basically I tried to write Bugzilla client on top of Ubiquity. Currently commands are under the heavy development so there's not much functionality there yet, but in case if you'd like to <a href="http://gozala.github.com/ubiquity/commands/bugzilla/" target="_blank">test it</a> or you want to look at the <a href="http://github.com/Gozala/ubiquity/blob/master/commands/bugzilla/command.js" target="_blank">source</a> you're able to.

You might already guessed that the command will be quite complex one. Actually that one of the issues I've faced. While it's really simple to develop small commands, it becomes almost impossible to work on complex ones. By the small commands I mean commands which are performing one / two tasks, and accepts only one / two modifiers. To give a better understanding what I mean I will try to write some user cases.
<ul>
	<li>As a user I would like to have one command to perform all the tasks used during work-flow.
What I mean is that command should have kind of *namespace?* or something like a *topic* which you are comunnicating with ubiquity with. It should be kind of keyword to describe the *target* against what my *actions* are performed.</li>
	<li> I want to have a set of verbs to describe what *actions* I am going to perform against the *target*</li>
	<li>I want to have *modifires* to describe what exactly the *actions* should do with the target.</li>
	<li>To keep simplicity of use I would expect that ubiquity will remember whatever I was talking about. I mean I don't like to describe all the details (*modifires*) in every sentence I'm writing. <span style="text-decoration:underline;">For example</span>: when I am talking with a person about a *bug* in _*firefox*_, which occurs only on *_Linux_*, I don't repeat in the same details in each sentence during talk,<span style="text-decoration:underline;">I don't say that</span> :I have *added* the *comment* to the *bug* in _*firefox*_, which occurs only on *_Linux_*, that _*I was not able to reproduce it*_.
<span style="text-decoration:underline;">I would rather say</span>_ _:

I have *added* the *comment* to the *bug*_* *_that _*I was not able to reproduce it*_"

As I expect that person I'm talking with still remembers what I was talking about in a previous sentence_*.
*_

_*
*_</li>
</ul>
Lets take a look at the real life examples now, what features I would like to have in my Bugzilla command[s].
<ul>
	<li>I'd like to <span style="color:#ff99cc;">*get*</span> <span style="color:#3366ff;">*information*</span> about *bug *in bugzilla system. (There can be several bugzilla systems like one from mozilla one from kde ...)</li>
	<li>I'd like to* *be able to store my <span style="color:#008000;">*<span style="background-color:#ffff00;">sessions</span>*</span> the way I'll be able to simply identify the origin of the <span style="color:#800000;">*bug*</span> I'm talking. I mean which bugzilla system is it coming from which.</li>
	<li><span style="color:#ff99cc;">*comment*</span> on the *bug* with some useful *<span style="color:#3366ff;">information</span> *(again in particular bugzilla <span style="color:#008000;">*<span style="background-color:#ffff00;">session</span>*</span> )
*
*</li>
	<li>I'd like to <span style="color:#ff99cc;">*get*</span> <span style="color:#3366ff;">*information*</span> about *<span style="color:#800000;">user</span> *(can get user by <span style="color:#800000;">*username*</span>, <span style="color:#800000;">*email*</span> ) again in particular bugzilla <span style="color:#008000;">*<span style="background-color:#ffff00;">session</span>*</span> )</li>
</ul>
In the example above we have
<ul>
	<li><span style="text-decoration:underline;">actions</span> :  get, comment</li>
	<li><span style="text-decoration:underline;">actual data</span> : information</li>
	<li><span style="text-decoration:underline;">modifires</span> : bug, session, user, username, email</li>
</ul>
but the problem is that action <span style="color:#ff99cc;">*get*</span> can handle two different modifiers <span style="color:#800000;">*bug*</span> and  <span style="color:#800000;">*user*</span>, lets assume that in case of <span style="color:#800000;">*bug*</span> its just a number / id, while in case of <span style="color:#800000;">*user*</span> it's bit complicated cause it can take <span style="color:#800000;">*username*</span> or <span style="color:#800000;">*email*</span> besides it just needs one not the both of them.
Possible solution would be to add all of the modifiers to the get command but the bad thing about it is that then you have to calculate which modifiers have been passed and guess based on that what user meant to get info for a user or for a bug. We should keep in mind that we can confuse users that way as well as they will see all this possible modifiers. One disadvantage is that lets suppose user is confused and have typed something like:
*get 156 me@email.com* is user trying to find a bug or user? Well he's confused we can manage to find it out but in that case we have to add extra parsing of the user input
one more example
*get bug 156* username me* is user still looking for a bug or user should we suggest bugs with numbers starting with 156 or users with the names me or both ?

Obviously adding all of the modifiers is a bad solution cause in real life example it's much more complex cause you can get bug by: assignees, reporters, resolution, by report date, by target os and many more modifiers. and it's actually the same with user a user. Even worse some of them can have same modifires like user_id so if you search by assignees you're passing the user_id and you can do the same if you're looking for the users with the user_id. Sure it's possible to identify them with different names but for a complex commands it still a nightmare, and no way simple to use for end users.
Well there's another solution to use different names for actions, actually that what usually ubiquity command developers do (From what I noticed), but unfortunately here is a limitation as we can't use space separated names for actions. So the solution is to have two commands *get-user* and *get-bug* in this case most of the problems are solved but in this case it's not really natural. Unfortunately that's not acceptable as well because even this names are quite common a lot of commands can have action like *get-user* so in order to tide *action* to a *target *we must do something like *bugzilla-get-user*, *bugzilla-get-bug*, with each step it becomes less and less natural :(. I have to say that in case of Bugzilla command[s] it's far from the reality, you still need more and more dashes.
I was thinking about alternative solution, how to keep things more natural how to scope command sets in one namespace. I think it could be done through dynamic modifiers. I mean modifiers which can have their own modifiers. What I mean is that based on input modifier should be able to ask for some more details / more modifiers.
Lets take a look at the flow below, suppouse I am asking some person called ubiquity to do something.
<ol>
	<li>*me:* Can you please make a *comment* to a bug ?</li>
	<li>*ubiquity: *What should be the *text* ? <span style="color:#339966;">(Asks input for comment)</span>_ _</li>
	<li>*me:* "_<span style="text-decoration:underline;">I'm not able to reproduce it" </span>_</li>
	<li>*ubiquity:* Suppose you're mean *bug* 146 or might be its one from  846, 400, 8942 <span style="color:#99cc00;"><span style="color:#339966;">(assumes that I'm talking about the bug I mentioned last time, but also suggests me some other bugs we've talked recently)</span></span></li>
	<li>*me:* *bug* 846</li>
	<li>*ubiquity:* so you mean *bug* 846 in *mozilla*<span style="color:#339966;"> (verifyes that I am talking about mozilla bugs as we talked about them last time)</span></li>
	<li>*me:* and attach *screenshot *please</li>
	<li>*ubiquity: *dou you like this one ??*
*</li>
	<li>*me: *perfect</li>
</ol>
I really hope you don't imagine that you have to type all this in the command line :)

Lets take a look at the same flow but if we were doing that with the commind line
<ol>
	<li>*bugzilla co<span style="color:#99ccff;">_<span style="background-color:#000000;">nnect</span>_</span>*_I started typeing "bugzilla co" as there are two actions (1. connect 2. comment) targeting bugzilla command ubiquity completes input with "bugzilla connect" because connect was used more recently. At the same time ubiquity selects auto-completed part to allow user go on with typing, it as well adds "comment" action to the suggestions.
__ _<span style="text-decoration:underline;">
in case if I press button:</span>
<ul>
	<li>right arrow / enter / tab
_in this case ubiquity will request / verify next modifier (there will be more details in the next slides)_</li>
	<li>down arrow
_in this case we'll have picture described in the 2nd list item._</li>
</ul>
</li>
	<li>*bugzilla comment _(text)_*
_ubiquity will autocomlete word "comment" and will show that it expects text input by adding and selecting "(text)"_ in case of having selected text in the browser selection will be inserted  and selected instead, if there is some data in the clipboard as well it will be suggested as an input through suggestions
<span style="text-decoration:underline;">
in case if I:</span>
<ul>
	<li>I will stop typing / will make delay
_in this case we'll have picture described in the 3nd list item._</li>
	<li>will press button right arrow / enter / tab
_in this case we'll have picture described in the 3nd list item._</li>
	<li>will press button left arrow
_action "comment" will be selected and the other bugzilla targeted actions will be suggested. In the preview help for the comment function will appear. in case of choosing other action all the following modifiers will disappear.
__ _</li>
	<li>will press down arrow
_in case of having suggestions will switch input data according to the suggestions_</li>
</ul>
</li>
	<li>*bugzilla comment " <span style="text-decoration:underline;">I'm not able to reproduce it"</span>_ on a bug <span style="color:#99ccff;"><span style="background-color:#000000;">146</span></span>_*
Ubiquity auto-completes with "on a bug 146" ("on a bug" is a prefix for modifier-bug). Selecting "146" as it's a modifier-bug accessed most recently, ubiquity verifies that I'm still interacting with it, at the same time it still gives me ability to type the id manually. It adds other bugs into suggestions 846, 400, 8942 as they've been recently used. Ubiquity suggests everything it has in history as the whole modifier is selected in this case. In the preview information for the currently selected bug (146) is shown.
<span style="text-decoration:underline;">
in case if I press button: </span>
<ul>
	<li> 8
_Ubiquity will auto-complete it with "46" (as it's was accessed more recently then 8942) and will select auto-completed part (46). In the suggestions only 8942 will show up as it's an only matching bug id from the history.  In the preview information for the currently selected bug (846) is shown._</li>
	<li>right arrow / enter / tab
_in this case ubiquity will request / verify next modifier
_</li>
	<li>down arrow
_in this case we'll have picture described in the 4th list item (as the first suggestion is _846_)._</li>
	<li>left arrow
_input _" <span style="text-decoration:underline;">I'm not able to reproduce it"</span>_ will be selected in case of having selection, clipboard data they will be suggested.
_</li>
</ul>
</li>
	<li>*bugzilla comment " <span style="text-decoration:underline;">I'm not able to reproduce it"</span>_ on a bug 846 in session <span style="color:#99ccff;"><span style="background-color:#000000;">mozilla</span></span>_*
Ubiquity auto-completes with "in the session mozilla" ("in the session " is prefix for modifier-session). Ubiquity verifies that it needs to use mozilla as modifier-session as it was used most recently. It also adds all the available sessions in suggestions cause whole modifier is selected. (kde, eclipse) At the same time in preview it shows info for *mozilla* session. (user, url)
<span style="text-decoration:underline;">
in case if I press button:</span>
<ul>
	<li>e
_Ubiquity will auto-complete it with "eclipse" (it's wasn't accessed more
recently then kde but it allows to go on typing unlike "kde") and will select auto-completed part ("clipse"). In the
suggestions only "kde" will show up as it's an only matching session. In the preview information for the currently selected session
(eclipse) is shown._</li>
	<li>right arrow / tab
_in this case ubiquity will put cursor in the end of the line and will show all possible (optional) modifiers in the suggestion.
_</li>
	<li>down arrow
_will select "kde" as a session_ and will select only matching part of it "e"</li>
	<li>left arrow
_modifier-bug __"846"_ _will be selected __in all possible suggestions will be suggested.
_</li>
	<li>_enter
Will add a comment to the bug__ _</li>
</ul>
</li>
	<li>*bugzilla comment " <span style="text-decoration:underline;">I'm not able to reproduce it"</span>_ on a bug 846 and attach <span style="color:#99ccff;"><span style="background-color:#000000;">(data) </span></span>_*
I have typed at as I wanted to attach file with a comment. Ubiquity did not suggested attach-modifier as it's an optional. but when I type "at", it auto-completes it with "and attach (data)" where "and attach " is a prefix for the attach-modifier. "(data)" got selected. Ubiquity suggests clipboard, screen-shot in the suggestions as that are the magic words which attach-modifier can take as an input.</li>
</ol>
Think all the cases should be quite clear now :)

What are the advantages of this kind of architecture:
<ul>
	<li>All the commands performing the actions against one target can be scoped by the namespace. Actually it can be a one command.</li>
	<li>Command Modifiers can have their own modifiers, that makes it possible to create better abstraction layer of the services on top of the Ubiquity.</li>
	<li>Modifiers have are ordered in a logical way, and some of them can be optional, value of one modifier can automatically make useless use of another modifier.</li>
	<li>Makes commands more closer to the natural language, cause in this model modifier is modeled as a sentence. Use of prefixes, suffixes makes it much easier to represent in more human way (it's even more important in some languages where suffix / prefix can change whole meaning of the sentence)</li>
	<li>Modifier is having step by step dialog with a user, keeping user focused more on the step rather on the end result.</li>
	<li>Asks user for input only in case if there is no other way</li>
	<li>User types only the data no modifier names.</li>
	<li>Ubiquity uses history to make discussion more intuitive. (Actually it's possible to do it even now through commands but think it might have a sense to expose this functionality some in some standard manner to the developers)</li>
</ul>