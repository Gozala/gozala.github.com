---
layout: post
title: Addons in multi process future
tags: jetpack AST isolate analysis
published: false
---

In add-on SDK we have a problem that is being both annoying and confusing
for a lot of our users. Also problem is not SDK specific and maybe
interesting for anyone dealing with JS in concurrent execution contexts.

## Problem overview

Add-on SDK was designed to be compatible with browser architecture where
chrome and content may be in a separate isolated processes. This imposes
a lot of limitations on how add-on code can interact with a page / tab
content and lack of concurrency constructs in a language make this problems
a lot more irritating. In SDK we end up implementing API that resembles
[web workers][] a lot. Main add-on code can execute content scripts in a
page contexts that act like workers and interaction between add-on and
content scripts happen through a message passing _(for more details please
take a look at [content script][] documention)_

We quickly discovered that not a lot of people are comfortable with message
passing APIs, but even putting that aside it's really annoying to be creating
separate content script files for a few lines of code (most of the add-ons
have content scripts that consist of few lines of code, unless accompanied
with external js libraries like jQuery):

    #!env/javascript
    var pageMod = require("sdk/page-mod")
    
    var mod = new pageMod.PageMod({
      include: ["*.co.uk"],
      contentScriptFile: require("self").data.url("./my.js")
    }))
    
As an option we also allow passing content scripts in form of JS string, which is
far from ideal:

	#!env/javascript
	var pageMod = require("page-mod")
 
	pageMod.add(new pageMod.PageMod({
  	  include: ["*.co.uk"],
  	  contentScript: "document.body.innerHTML = " +
                 	 "'<h1>this page has been eaten</h1>'"
	}))

What you would actully want is to just write a function that will be executed
in the context of the content. Unfortunately it's not just matter of serialising
function and then evaluating it in the context, since functions can access bindings
from the outer scopes.

## Idea

If we could prove that function does not refers to anything but arguments
passed to it or definitions with in it, it would be pretty safe to transplant
it into completely different execution context:

    #!env/javascript
    var pageMod = require("sdk/page-mod")
    
    var mod = new pageMod.PageMod({
      include: ["*.co.uk"],
      contentScript: isolate(function() {
        document.body.innerHTML = "<h1>this page has been eaten</h1>"
    }))
    


[content script]:https://addons.mozilla.org/en-US/developers/docs/sdk/latest/dev-guide/guides/content-scripts/index.html
[web workers]:https://developer.mozilla.org/en-US/docs/DOM/Using_web_workers
